Práctica 2 de Redes 1
Grupo 1391
Pareja 12
Autoras: Paula Beltrán Marianini y Lucía Gil Maroto


Aunque en la entrega de la práctica no se especifica, para completar este archivo leeme.txt
vamos a aportar capturas de pantalla que justifiquen la realización de todos los ejercicios
y comprobaciones necesarias de cara a completar los criterios de evaluación que hemos cumplido.

En el archivo practica2.py no hemos modificado nada. En cambio, en el archivo arp.py, 
a parte de implementar el código que nos pedían, hemos añadido algunos imports y hemos
añadido algunas variables (variables.jpeg).

Ejecución de pruebas:
	1. Pruebas de resolución de direcciones --> Abrimos en la terminal la aplicación
	Mininet con el comando "sudo mn --nat". 
		1.1. A continuación abrimos los dos hosts con el comando "gterm h1 h2".
		1.2. Comprobamos las configuraciónes de h1 y h2 con el comando "ifconfig"
		1.3. y 1.4. Ejecutamos el script e introducimos la ip de h2 en la terminal de h1
		y viceversa.
		1.5. Introducimos el comando p para que muestre el caché (cache.jpeg).
		1.6. Solicitamos la IP de h2 de nuevo y comprobamos que no hay petición ARP (cache.jpeg).

* Para comprobar si se producen o no peticiones ARP (como hemos implementado nuestro código con
numerosos mensajes debug por si había errores) hemos considerado que la mejor forma de considerarlo
era añadir unos prints en arp.py. En la función ARPResolution, si entra en el if para comprobar si la ip 
está en el caché (linea 357), no habrá petición ARP; mientras que si no lo está, no entrará en el if y se producirá
la llamada. 

	2. Pruebas de inicialización -->  Abrimos en la terminal la aplicación
	Mininet con el comando "sudo mn -nat". 
		1.1. A continuación abrimos los dos hosts con el comando "gterm h1 h2".
		1.2. y 1.3. Comprobamos las configuraciónes de h1 y h2 con el comando "ifconfig"
		Para cambiar la configuración de h2, utilizaremos el comando "sudo ifconfig h2-eth0 10.0.0.1"
		que significa que queremos asignar a h2-eth0 la ip 10.0.0.1. Comprobamos la asignación
		con el comando "ifconfig" y vemos que la ip ha cambiado (cambiar_ip_h2.jpeg)
		1.4. y 1.5. Primero, abrimos de nuevo "ifconfig" en ambas terminales para comprobar
		la información de ambos hosts. Tratamos de ejecutar el script de la práctica y 
		obtenemos un mensaje de error porque h1 y h2 tienen la misma ip (prueba_iniciación.jpeg) 

* Hemos comprobado que nuestro programa funciona desde todos los ámbitos que el profesor nos ha indicado.

	- La comprobación en la que nuestro programa interacciona con nuestro programa se ve en myprogram-myprogram.jpeg
	donde (previamente habiendo desactivado la respuesta arp del sistema operativo con el comando "ip link set dev h1-eth0 arp off",
	siendo h1-eth0 el nombre de nuestra interfaz).

	- La comprobación en la que nuestro programa interacciona con el sistema operativo se ve en myprogram-soper.jpeg
	donde a través de wireshark, sin haber ejecutado el programa en h2, vemos que se realizan adecuadamente las request
	y se devuelve la dirección de h2 igualmente. Si por el contrario, tratamos de repetir esto mismo habiendo
	desactivado previamente la respuesta arp del sistema operativo en h2, comprobamos en myprogram-soper_off.jpeg
	que la dirección no se encuentra.

	- La comprobación en la que el sistema operativo interacciona con nuestro programa la realizamos en soper-myprogram.jpeg.
	Primero borramos el caché con el comando arp -d 10.0.0.2; luego introducimos el comando ping 10.0.0.2 y finalmente comprobamos
	que está guardada con el comando arp -a.

	- A su vez, hemos comprobado desde wireshark que las cabeceras de las tramas están correctamente 
	formadas y la información que contienen es la que deberían en función de los bytes que ocupan y
	el contenido de esos bytes.

¿A qué hemos dado respuesta?

	- Normativa de entrega cumplida en su totalidad: 5% --> Realizado: Hemos hecho varias 
	lecturas del enunciado, comprobando que completabamos cada uno de los puntos sin olvidar
	ninguno, así como la normativa de entrega, con los correspondientes nombres de los archivos a 
	entregar. La funcionalidad la hemos explicado en la ejecución de pruebas.

	- Fichero leeme.txt bien explicado: 5% --> Realizado: este es nuestro archivo leeme.txt con 
	todos los puntos de la práctica explicados y justificados, así como una explicación de lo 
	realizado fuera del guión.

	- Recibir tramas Ethernet, realizar comprobaciones y llamar correctamente a la función de 
	callback de nivel superior: 10% --> La recepcción de tramas ethernet se realiza con la función
	"process_frame", que le asignaremos apcap_loop.

	- Enviar tramas Ethernet  correctamente: 10% --> Realizado con la función sendEthernetFrame() 
	llamando a la función pcap_inject. En caso de haber un error, se printearía un mensaje 
	diciendo que lo hubo.

	- Enviar correctamente peticiones ARP: 10% --> Realizado, solo se envia una petición ARP
	cuando la ip no está en el caché. Esta comprobación se realiza con la función ARPResolution,
	donde se llama después a createARPRequest y se envía con sendEthernetFrame().

	- Procesar correctamente peticiones ARP recibidas: 15% --> Realizado, cuando llega una trama
	ARP se ejecuta la función callback ProcessARPFrame que comprueba si la cabecera es correcta.
	Si lo es, se comprueba si es respuesta o petición (en este caso la segunda) y se llamará a
	processARPRequest. En el caso de que haya algún error, la petición se ignora.

	- Enviar correctamente respuestas ARP: 10% --> Realizado, primero se contruye la respuesta
	llamando a la función createARPReply, y luego se envía mediante sendEthernetFrame().

	- Procesar correctamente respuestas ARP: 15% --> Realizado, una vez que se determina que se
	trata de una respuesta ARP, se llama a la función processARPReply.

	- Manejo correcto de la caché ARP: 5% --> Realizado, primero en la función ARPResolution()
	comprobamos si la ip en el caché. Si lo está, se devuelve la MAC asociada a esa IP. Además,
	la hemos implementado con un uso correcto de los Locks cuando queremos acceder a la información.

	- Uso correcto de Locks: 5% --> Realizado, cada vez que queremos cambiar el valor de alguna
	de las variables globales que se leen y escriben concurrentemente utilizamos los Locks. Para 
	bloquear una variable global utilizamos globalLock.acquire() y para bloquear el caché,
	cacheLock.acquire() y para desbloquearlas utilizaremos globalLock.release() y cacheLock.release()
	respectivamente. 

	- Realiza correctamente el ARP gratuito: 10% --> Realizado, se explica en el punto Pruebas de inicialización y el resultado es
	el que se espera, tratamos de ejecutar el script de la práctica y obtenemos un mensaje de error porque h1 y h2 tienen la 
	misma ip (prueba_iniciación.jpeg)
