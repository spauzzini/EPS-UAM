Grado 2021/22
— Curso 2021/22 —
Campus Virtuales 
Ayuda 
 
English ‎(en)‎
Español - Internacional ‎(es)‎
 
 Lucia Gil Maroto
 
 Área personal
 Perfil
 Calificaciones
 Mensajes
 Preferencias
 
 Cerrar sesión
Salta al contenido principal
REDES DE COMUNICACIONES I TODOS
Área personal
Cursos
Grado
Escuela Politécnica Superior
Graduado/a en Ingeniería Informática y Matemáticas (2019)
Tercer Curso
Primer Semestre
2021_17835_130_2
Prácticas
Práctica 3: IP, UDP e ICMP
Práctica 3: IP, UDP e ICMP

Objetivos de la práctica
Familiarizarse con el protocolo de nivel de red IP y con los protocolos UDP e ICMP
Entender las cabeceras y aprender a implementar protocolos de comunicaciones complejos
Implementar un programa con funcionalidades similares al comando ping.

Introducción
Esta práctica tiene por objeto implementar los niveles intermedios de la pila TCP/IP. Específicamente se construirá el nivel de red que en este caso se implementará usando el protocolo IP y el nivel de transporte que se implementará usando el protocolo UDP. Adicionalmente implementaremos un caso de uso del protocolo ICMP el cual sirve para notificar errores y realizar tareas de operación relacionadas con el nivel IP.


El objetivo final de esta práctica es implementar un programa que nos permita enviar tanto datagramas UDP que contengan datos útiles como mensajes ICMP de tipo Echo request/reply comúnmente conocidos como "ping".





A continuación analizaremos las cabeceras de IP, UDP e ICMP. Podemos obtener la descripción de cabeceras pedidas en sus respectivas RFCs (de aquí en castellano: http://www.rfc-es.org/).



Internet Procotol v4(RFC 790):

IP es un protocolo de nivel de red que permite enviar información extremo a extremo a lo largo de varios saltos. A continuación analizaremos el formato que tiene la cabecera de un datagrama IP.



cabecera IP



Campos:

Versión (4 bits): Campo que indica la versión de IP. En nuestro caso será siempre 4
IHL (4 bits): Longitud de la cabecera IP. Como la cabecera IP puede contener opciones de tamaño variable este campo nos indica el tamaño de la cabecera. Este campo está expresado en palabras de 4 bytes. Es decir, para obtener el tamaño total (en número de bytes) de la cabecera es necesario multiplicar este campo por 4. El tamaño mínimo de una cabecera IP es 20 bytes y el máximo 60.
Type of Service (1 byte): indicador del tipo de tráfico que transporta este datagrama. Este campo sirve para priorización y marcado de tráfico. En nuestro caso siempre usaremos el valor 0.
Total Length(2 Bytes): Longitud total (en número de bytes) del datagrama IP actual. Incluye tanto la cabecera como el payload que va detrás de la cabecera.
Identification (2 Bytes): Identificador del datagrama IP (también llamado IPID). Este campo es útil cuando hay fragmentación IP. En este caso todos los fragmentos tienen el mismo valor de IPID.
Flags (3 bits): Banderas IP:
Bit 1 (Reservado): siempre a 0
Bit 2 (DF): bandera que indica que no debe fragmentarse el datagrama. En nuestro caso será siempre 0.
Bit 3 (MF): bandera que indica que vienen más fragmentos tras el datagrama actual. En caso de fragmentar todos los fragmentos tendrán este bit a 1 menos el último fragmento.
Offset (13 bits): campo que indica (en caso de fragmentación) el offset de los datos contenidos en el datagrama actual respecto al total de datos sin fragmentar. Está expresado en palabras de 8 bytes. Es decir, para obtener el valor real de offset se debe multiplicar este campo por 8.
Time to Live  (1 Byte): campo que indica el número máximo de saltos IP que puede realizar el datagrama actual antes de ser descartado. Cada vez que un paquete atraviesa un salto a nivel IP se decrementa en 1 y cuando llega a 0 el datagrama actual se descarta. En nuestro caso usaremos el valor por defecto 64.
Protocol (1 Byte): Campo que indica el protocolo de nivel superior encapsulado en el payload del datagrama. Este campo tiene un cometido similar al campo Ethertype en Ethernet. Algunos valores típicos son: 1 para ICMP, 6 para TCP y 17 para UDP.
Header Checksum (2 Bytes): suma de verificación calculada sobre la cabecera IP que sirve para detectar errores o modifcaciones de la cabecera IP durante el envío de datos. Cuando recibimos un datagrama, si el cálculo de checksum es erróneo debemos descartarlo.
Dirección IP origen (4 Bytes): dirección IP del emisor del datagrama actual
Dirección IP destino (4 Bytes): dirección IP del receptor del datagrama
Opciones (Tamaño variable): Opciones que aportan funcionalidades adicionales. Su tamaño tiene que ser múltiplo 4 bytes. El tamaño mínimo de opciones es 0 bytes y el máximo 40 bytes.
Tamaños de los datagramas:

El tamaño máximo que puede enviarse a nivel IP (cabecera + datos) viene definido por la  Maximum Transmission Unit (MTU). Este valor depende del protocolo de nivel inferior, en nuestro caso Ethernet. En nuestro caso la MTU es típicamente 1500 Bytes pero este valor puede variar.
Cuando los datos a enviar no caben en un único datagrama IP se realiza un proceso de fragmentación. Para ello se parten los datos en fragmentos y cada fragmento se envía junto con su propia cabecera IP. En este caso cada fragmento tendrá un valor diferente en los campos Total Length, MF ,offset y checksum. El resto de campos serán los mismos en todos los fragmentos. 
Ejemplo de fragmentación:

Queremos enviar 3699 bytes de datos utilizando el protocolo IP. 
Sabiendo que  la MTU es 1500 primeramente debemos calcular el número de fragmentos a enviar. Para ello calculamos primeramente la cantidad máxima de datos útiles que podemos encapsular en un datagrama IP. Esta cantidad será: MTU-long_cabecera_IP. Si suponemos que la cabecera no tiene opciones este valor sería 1500-20=1480 Bytes. 
A continuación debemos comprobar si esta cantidad máxima de datos útiles es múltiplo de 8. Esta comprobación es obligatoria porque el offset está expresado en palabras de 8 bytes. En caso de que no lo sea usaremos el valor más cercano por abajo. Como 1480 sí es múltiplo de 8 usaremos ese valor.
Calculamos el número de fragmentos a enviar. Para ello dividimos el total de datos a enviar/cantidad máxima de datos útiles. En nuestro ejemplo: 3699/1480=2,49. Como no podemos enviar un número decimal de fragmentos enviaremos 3 fragmentos (el último no irá completamente lleno).
El primer fragmento tendrá longitud 20 (cabecera) + 1480 (datos) bytes . El valor de MF será 1 (hay más fragmentos detrás) y el offset será 0 (los 1480 bytes contenidos en este primer datagrama empiezan en la posición 0 respecto al inicio de los datos originales).
El segundo fragmento tendrá longitud 20 (cabecera) + 1480 (datos) bytes . El valor de MF será 1 (hay más fragmentos detrás) y el offset será 1480/8=185 (los datos contenidos en este segundo datagrama empiezan en la posición 1480 respecto al inicio de los datos originales).
El ultimo fragmento tendrá longitud 20 (cabecera) + 739 (datos) bytes. El valor de MF=0 (este es el último fragmento) y el offset será 2960/8=370 (los datos contenidos en este último datagrama empiezan en la posición 2960 respecto al inicio de los datos originales)
En la siguiente imagen se muestra este ejemplo:



frag



Cambio de MTU de una interfaz:

Para hacer pruebas de fragmentación  se recomienda cambiar la MTU de la interfaz. Para cambiar la MTU de una interfaz en Linux debemos ejecutar en una terminal:

ifconfig nombre_interfaz mtu valor_mtu



Ejemplo:



ifconfig h1-eth0 mtu 600





UDP(RFC 768):



UDP es un protocolo de nivel de transporte no fiable y  no orientado a conexión que permite enviar datagramas. UDP se usa normalmente para implementar por encima protocolos de nivel de aplicación no orientados a flujo o que tienen restricciones de tiempo real y en los cuales el concepto de retransmisión no tiene sentido. Por ejemplo los protocolos de nivel de aplicación DNS,DHCP o RTP son protocolos que hacen uso de UDP como nivel de transporte.



Cabecera:





El protocolo UDP  tiene una cabecera fija de 8 bytes. A continuación se muestra dicha cabecera:

udp






